
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>vision: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Soup666/diss-api/cmd/vision/main.go (0.0%)</option>
				
				<option value="file1">github.com/Soup666/diss-api/controller/auth_controller.go (0.0%)</option>
				
				<option value="file2">github.com/Soup666/diss-api/controller/collections_controller.go (0.0%)</option>
				
				<option value="file3">github.com/Soup666/diss-api/controller/object_controller.go (0.0%)</option>
				
				<option value="file4">github.com/Soup666/diss-api/controller/reports_controller.go (0.0%)</option>
				
				<option value="file5">github.com/Soup666/diss-api/controller/task_controller.go (0.0%)</option>
				
				<option value="file6">github.com/Soup666/diss-api/controller/upload_controller.go (0.0%)</option>
				
				<option value="file7">github.com/Soup666/diss-api/controller/vision_controller.go (0.0%)</option>
				
				<option value="file8">github.com/Soup666/diss-api/database/database.go (76.9%)</option>
				
				<option value="file9">github.com/Soup666/diss-api/docs/docs.go (0.0%)</option>
				
				<option value="file10">github.com/Soup666/diss-api/main.go (0.0%)</option>
				
				<option value="file11">github.com/Soup666/diss-api/middleware/authenticate_middleware.go (100.0%)</option>
				
				<option value="file12">github.com/Soup666/diss-api/middleware/cors_middleware.go (0.0%)</option>
				
				<option value="file13">github.com/Soup666/diss-api/model/report_type.go (100.0%)</option>
				
				<option value="file14">github.com/Soup666/diss-api/model/task.go (80.0%)</option>
				
				<option value="file15">github.com/Soup666/diss-api/model/task_status.go (100.0%)</option>
				
				<option value="file16">github.com/Soup666/diss-api/repository/app_file_repository_impl.go (0.0%)</option>
				
				<option value="file17">github.com/Soup666/diss-api/repository/chat_repository_impl.go (0.0%)</option>
				
				<option value="file18">github.com/Soup666/diss-api/repository/collections_repository_impl.go (40.9%)</option>
				
				<option value="file19">github.com/Soup666/diss-api/repository/reports_repository_impl.go (50.0%)</option>
				
				<option value="file20">github.com/Soup666/diss-api/repository/task_repository_impl.go (50.0%)</option>
				
				<option value="file21">github.com/Soup666/diss-api/repository/user_repository_impl.go (84.6%)</option>
				
				<option value="file22">github.com/Soup666/diss-api/router/router.go (0.0%)</option>
				
				<option value="file23">github.com/Soup666/diss-api/seeder/seeder.go (0.0%)</option>
				
				<option value="file24">github.com/Soup666/diss-api/seeds/files.go (0.0%)</option>
				
				<option value="file25">github.com/Soup666/diss-api/seeds/seeds.go (0.0%)</option>
				
				<option value="file26">github.com/Soup666/diss-api/seeds/tasks.go (0.0%)</option>
				
				<option value="file27">github.com/Soup666/diss-api/seeds/users.go (0.0%)</option>
				
				<option value="file28">github.com/Soup666/diss-api/services/app_file_service_impl.go (0.0%)</option>
				
				<option value="file29">github.com/Soup666/diss-api/services/auth_service_impl.go (0.0%)</option>
				
				<option value="file30">github.com/Soup666/diss-api/services/collections_service_impl.go (0.0%)</option>
				
				<option value="file31">github.com/Soup666/diss-api/services/file_service_impl.go (0.0%)</option>
				
				<option value="file32">github.com/Soup666/diss-api/services/reports_service_impl.go (0.0%)</option>
				
				<option value="file33">github.com/Soup666/diss-api/services/task_service_impl.go (5.4%)</option>
				
				<option value="file34">github.com/Soup666/diss-api/services/user_service_impl.go (70.0%)</option>
				
				<option value="file35">github.com/Soup666/diss-api/services/vision_service_impl.go (0.0%)</option>
				
				<option value="file36">github.com/Soup666/diss-api/utils/file_util.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"

        "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        client, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv("GEMINI_API_KEY")))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        model := client.GenerativeModel("gemini-2.0-flash")

        // Download the image.
        imageResp, err := http.Get("https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Palace_of_Westminster_from_the_dome_on_Methodist_Central_Hall.jpg/2560px-Palace_of_Westminster_from_the_dome_on_Methodist_Central_Hall.jpg")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer imageResp.Body.Close()

        imageBytes, err := io.ReadAll(imageResp.Body)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Create the request.
        <span class="cov0" title="0">req := []genai.Part{
                genai.ImageData("jpeg", imageBytes),

                genai.Text("Caption this image."),
        }

        // Generate content.
        resp, err := model.GenerateContent(ctx, req...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Handle the response of generated text.
        <span class="cov0" title="0">for _, c := range resp.Candidates </span><span class="cov0" title="0">{
                if c.Content != nil </span><span class="cov0" title="0">{
                        fmt.Println(*c.Content)
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "net/http"

        models "github.com/Soup666/diss-api/model"
        services "github.com/Soup666/diss-api/services"

        "github.com/gin-gonic/gin"
)

// AuthController is the controller for handling authentication requests
type AuthController struct {
        authService services.AuthService
        userService services.UserService
}

func NewAuthController(authService services.AuthService, userService services.UserService) *AuthController <span class="cov0" title="0">{
        return &amp;AuthController{authService, userService}
}</span>

func (c *AuthController) Verify(ctx *gin.Context) <span class="cov0" title="0">{

        switch ctx.Request.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">

                token, exists := ctx.Get("token")
                if !exists </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(400, gin.H{"error": "Token not found"})
                        return
                }</span>

                // Register the new user and get a custom token for the user
                <span class="cov0" title="0">user, err := c.authService.Verify(token.(string))
                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                        return
                }</span>

                // Return the custom token to the client
                <span class="cov0" title="0">ctx.JSON(200, gin.H{"user": user})</span>

        case http.MethodPatch:<span class="cov0" title="0">
                user := ctx.MustGet("user").(*models.User)

                var userUpdate models.User
                if err := ctx.ShouldBindJSON(&amp;userUpdate); err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(400, gin.H{"error": "Invalid request body"})
                        return
                }</span>

                // Fields allowed to be updated
                <span class="cov0" title="0">user.Email = userUpdate.Email

                err := c.userService.UpdateUser(user)

                if err != nil </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov0" title="0">ctx.JSON(200, gin.H{"user": user})</span>
        default:<span class="cov0" title="0">
                ctx.AbortWithStatusJSON(http.StatusMethodNotAllowed, gin.H{"error": "Method not allowed"})
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/Soup666/diss-api/model"
        services "github.com/Soup666/diss-api/services"
        "github.com/gin-gonic/gin"
)

type CollectionsController struct {
        collectionsService services.CollectionsService
}

func NewCollectionsController(collectionsService services.CollectionsService) *CollectionsController <span class="cov0" title="0">{
        return &amp;CollectionsController{collectionsService: collectionsService}
}</span>

func (c *CollectionsController) CreateCollection(ctx *gin.Context) <span class="cov0" title="0">{
        collection := &amp;model.Collection{}

        if err := ctx.ShouldBindJSON(collection); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">user := ctx.MustGet("user").(*model.User)
        collection.UserID = &amp;user.Id

        err := c.collectionsService.CreateCollection(collection)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"collection": collection})</span>
}

func (c *CollectionsController) GetCollection(ctx *gin.Context) <span class="cov0" title="0">{
        collectionIDParam := ctx.Param("collectionID")
        collectionID, err := strconv.Atoi(collectionIDParam)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collection ID"})
                return
        }</span>

        <span class="cov0" title="0">collection, err := c.collectionsService.GetCollection(uint(collectionID))
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(200, gin.H{"collection": collection})</span>
}

func (c *CollectionsController) GetCollections(ctx *gin.Context) <span class="cov0" title="0">{
        user := ctx.MustGet("user").(*model.User)

        collections, err := c.collectionsService.GetCollections(user.Id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(200, gin.H{"collections": collections})</span>
}

func (c *CollectionsController) ArchiveCollection(ctx *gin.Context) <span class="cov0" title="0">{
        collectionIDParam := ctx.Param("collectionID")
        collectionID, err := strconv.Atoi(collectionIDParam)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collection ID"})
                return
        }</span>

        <span class="cov0" title="0">if err := c.collectionsService.ArchiveCollection(uint(collectionID)); err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusNoContent, nil)</span>
}

func (c *CollectionsController) SaveCollection(ctx *gin.Context) <span class="cov0" title="0">{
        collection := &amp;model.Collection{}

        if err := ctx.ShouldBindJSON(collection); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">user := ctx.MustGet("user").(*model.User)
        collection.UserID = &amp;user.Id

        err := c.collectionsService.SaveCollection(collection)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"collection": collection})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "os"

        "github.com/gin-gonic/gin"
)

// AuthController is the controller for handling authentication requests
type ObjectController struct{}

func NewObjectController() *ObjectController <span class="cov0" title="0">{
        return &amp;ObjectController{}
}</span>

func (c *ObjectController) GetObject(ctx *gin.Context) <span class="cov0" title="0">{
        taskId := ctx.Param("taskID")

        // Construct the full file path
        filePath := fmt.Sprintf("objects/%s/%s", taskId, "mvs/final_model.glb")

        // Check if the file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "Object not found"})
                return
        }</span>

        // Serve the file
        <span class="cov0" title="0">ctx.File(filePath)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/Soup666/diss-api/model"
        services "github.com/Soup666/diss-api/services"
        "github.com/gin-gonic/gin"
)

type ReportsController struct {
        reportsService services.ReportsService
}

func NewReportsController(reportsService services.ReportsService) *ReportsController <span class="cov0" title="0">{
        return &amp;ReportsController{reportsService: reportsService}
}</span>

func (c *ReportsController) GetReports(ctx *gin.Context) <span class="cov0" title="0">{

        user := ctx.MustGet("user").(*model.User)

        reports, err := c.reportsService.GetReports(uint(user.Id))
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(200, gin.H{"reports": reports})</span>
}

func (c *ReportsController) GetReportByID(ctx *gin.Context) <span class="cov0" title="0">{

        reportIDParam := ctx.Param("reportID")
        reportID, err := strconv.Atoi(reportIDParam)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid report ID"})
                return
        }</span>

        <span class="cov0" title="0">report, err := c.reportsService.GetReport(uint(reportID))
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(200, gin.H{"report": report})</span>
}

func (c *ReportsController) CreateReport(ctx *gin.Context) <span class="cov0" title="0">{
        report := &amp;model.Report{}

        if err := ctx.ShouldBindJSON(report); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">user := ctx.MustGet("user").(*model.User)
        report.UserID = &amp;user.Id

        err := c.reportsService.CreateReport(report)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"report": report})</span>
}

func (c *ReportsController) ArchiveReport(ctx *gin.Context) <span class="cov0" title="0">{
        reportIDParam := ctx.Param("reportID")
        reportID, err := strconv.Atoi(reportIDParam)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid report ID"})
                return
        }</span>

        <span class="cov0" title="0">if err := c.reportsService.ArchiveReport(uint(reportID)); err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "Report archived successfully"})</span>
}

func (c *ReportsController) SaveReport(ctx *gin.Context) <span class="cov0" title="0">{
        report := &amp;model.Report{}
        if err := ctx.ShouldBindJSON(report); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">if err := c.reportsService.SaveReport(report); err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"report": report})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "errors"
        "fmt"
        "log"
        "mime/multipart"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"

        "github.com/Soup666/diss-api/database"
        "github.com/Soup666/diss-api/model"
        services "github.com/Soup666/diss-api/services"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type TaskController struct {
        TaskService    services.TaskService
        AppFileService services.AppFileService
        VisionService  services.VisionService
}

func NewTaskController(taskService services.TaskService, appFileService services.AppFileService, visionService services.VisionService) *TaskController <span class="cov0" title="0">{
        return &amp;TaskController{TaskService: taskService, AppFileService: appFileService, VisionService: visionService}
}</span>

func (c *TaskController) GetTasks(ctx *gin.Context) <span class="cov0" title="0">{

        user := ctx.MustGet("user")
        userId := user.(*model.User).Id

        tasks, err := c.TaskService.GetTasks(userId)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        // I dont like this being in a controller, but time constraints
        <span class="cov0" title="0">if err := database.DB.Preload("Mesh", "file_type = ?", "mesh").Find(&amp;tasks).Error; err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch tasks"})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(200, gin.H{"tasks": tasks})</span>
}

func (c *TaskController) GetTask(ctx *gin.Context) <span class="cov0" title="0">{

        // Get the Task ID from the route
        taskIDParam := ctx.Param("taskID")
        taskID, err := strconv.Atoi(taskIDParam)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid task ID"})
                return
        }</span>

        <span class="cov0" title="0">task, err := c.TaskService.GetTask(uint(taskID))
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        // Load relations
        <span class="cov0" title="0">c.TaskService.FullyLoadTask(task)

        ctx.JSON(200, gin.H{"task": task})</span>
}

// CreateTask handles task creation
// @Summary Create a new task
// @Description Creates a new task for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Param request body CreateTaskRequest true "Task data"
// @Security BearerAuth
// @Success 201 {object} model.Task
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /tasks [post]
func (c *TaskController) CreateTask(ctx *gin.Context) <span class="cov0" title="0">{
        user := ctx.MustGet("user").(*model.User)

        task := &amp;model.Task{
                Title:       "",
                Description: "", // Overriden by ai-description
                UserId:      &amp;user.Id,
                Completed:   false,
                Status:      "INITIAL",
        }

        err := c.TaskService.CreateTask(task)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating task: %v", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create task"})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"task": task})</span>
}

// UploadFileToTask handles file uploads for a task
// @Summary Upload files to a task
// @Description Uploads files to a task
// @Tags tasks
// @Accept json
// @Produce json
// Security BearerAuth
// @Param taskID path string true "Task ID"
// @Param files formData file true "Files to upload"
// @Success 201 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /tasks/{taskID}/upload [post]
func (c *TaskController) UploadFileToTask(ctx *gin.Context) <span class="cov0" title="0">{

        // Get the Task ID from the route
        taskIdParam := ctx.Param("taskID")
        taskId, err := strconv.Atoi(taskIdParam)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid task ID"})
                return
        }</span>

        // Check if the Task exists
        <span class="cov0" title="0">var task model.Task
        if err := database.DB.First(&amp;task, taskId).Error; err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "Task not found"})
                return
        }</span>

        // Retrieve files from the request
        <span class="cov0" title="0">form, err := ctx.MultipartForm()
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse form data"})
                return
        }</span>
        <span class="cov0" title="0">files := form.File["files"]
        if len(files) == 0 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "No files uploaded"})
                return
        }</span>

        // Define the upload folder
        <span class="cov0" title="0">folderPath := fmt.Sprintf("uploads/%d", taskId)
        if err := os.MkdirAll(folderPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create upload directory"})
                return
        }</span>

        <span class="cov0" title="0">var uploadedImages []model.AppFile
        var wg sync.WaitGroup
        var mu sync.Mutex
        var hasError bool

        // Use transactions for better consistency
        tx := database.DB.Begin()

        for index, file := range files </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(index int, file *multipart.FileHeader) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Validate file extension
                        fileExt := strings.ToLower(filepath.Ext(file.Filename))
                        if fileExt != ".jpg" &amp;&amp; fileExt != ".jpeg" &amp;&amp; fileExt != ".png" </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid file type"})
                                hasError = true
                                return
                        }</span>

                        // Generate a unique filename
                        <span class="cov0" title="0">filename := fmt.Sprintf("%d-%d%s", taskId, index, fileExt)
                        savePath := filepath.Join(folderPath, filename)

                        // Save the file
                        if err := ctx.SaveUploadedFile(file, savePath); err != nil </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to save file %s", file.Filename)})
                                hasError = true
                                return
                        }</span>

                        // Save metadata to DB
                        <span class="cov0" title="0">image := model.AppFile{
                                Filename: filename,
                                Url:      fmt.Sprintf("/uploads/%d/%s", taskId, filename),
                                TaskId:   uint(taskId),
                                FileType: "upload",
                        }

                        mu.Lock()
                        if err := tx.Create(&amp;image).Error; err != nil </span><span class="cov0" title="0">{
                                hasError = true
                        }</span> else<span class="cov0" title="0"> {
                                uploadedImages = append(uploadedImages, image)
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()</span>
                }(index, file)
        }

        <span class="cov0" title="0">wg.Wait()

        if hasError </span><span class="cov0" title="0">{
                tx.Rollback()
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upload some files"})
                return
        }</span>

        <span class="cov0" title="0">tx.Commit()

        go func() </span><span class="cov0" title="0">{
                // Generate caption
                result, err := c.VisionService.AnalyseImage(fmt.Sprintf("./uploads/%d/%s", taskId, uploadedImages[0].Filename), "")

                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Unable to analyze the image: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := c.TaskService.UpdateMeta(&amp;task, "ai-description", result); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update task metadata: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // Generate caption
                result, err := c.VisionService.AnalyseImage(fmt.Sprintf("./uploads/%d/%s", taskId, uploadedImages[0].Filename), "categorize the model in this image, use one word only")

                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Unable to analyze the image: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := c.TaskService.UpdateMeta(&amp;task, "ai-title", result); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update task metadata: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "message": "Files uploaded successfully",
                "images":  uploadedImages,
        })</span>
}

// StartProcess handles the process of starting the photogrammetry process
// @Summary Upload files to a task
// @Description Uploads files to a task
// @Tags tasks
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer Token"
// @Param request body CreateTaskRequest true "Task data"
// @Param taskID path string true "Task ID"
// @Success 201 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /tasks/{taskID}/start [post]
func (c *TaskController) StartProcess(ctx *gin.Context) <span class="cov0" title="0">{

        taskId := ctx.Param("taskID")
        taskIdInt, err := strconv.Atoi(taskId)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid task ID"})
                return
        }</span>

        <span class="cov0" title="0">task, err := c.TaskService.GetTask(uint(taskIdInt))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNotFound, gin.H{"error": "Task not found"})
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Error retrieving task: %v", err)
                        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">task.Completed = false
        if err := c.TaskService.SaveTask(task); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update task"})
                return
        }</span>

        // Respond to the client immediately
        <span class="cov0" title="0">ctx.JSON(http.StatusAccepted, gin.H{"message": "Process started."})

        go c.TaskService.RunPhotogrammetryProcess(task)</span>
}

func (c *TaskController) UpdateTask(ctx *gin.Context) <span class="cov0" title="0">{
        task := &amp;model.Task{}

        if err := ctx.ShouldBindJSON(task); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">user := ctx.MustGet("user").(*model.User)
        task.UserId = &amp;user.Id

        _, err := c.TaskService.UpdateTask(task)
        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"task": task})</span>
}

func (c *TaskController) SendMessage(ctx *gin.Context) <span class="cov0" title="0">{

        taskId := ctx.Param("taskID")
        taskIdInt, err := strconv.Atoi(taskId)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid task ID"})
                return
        }</span>

        <span class="cov0" title="0">type MessageBody struct {
                Message string
        }

        chatMessage := &amp;MessageBody{}

        if err := ctx.ShouldBindJSON(chatMessage); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">message, err := c.TaskService.SendMessage(uint(taskIdInt), chatMessage.Message, "USER")

        if err != nil </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": message})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"

        "github.com/Soup666/diss-api/database"
        models "github.com/Soup666/diss-api/model"

        "github.com/gin-gonic/gin"
)

// AuthController is the controller for handling authentication requests
type UploadController struct {
}

func NewUploadController() *UploadController <span class="cov0" title="0">{
        return &amp;UploadController{}
}</span>

func (c *UploadController) UploadFile(ctx *gin.Context) <span class="cov0" title="0">{

        file, header, err := ctx.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "File upload failed"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Save the file
        savePath := filepath.Join("uploads", header.Filename)
        out, err := os.Create(savePath)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to save the file"})
                return
        }</span>
        <span class="cov0" title="0">defer out.Close()

        _, err = io.Copy(out, file)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to save the file"})
                return
        }</span>

        // Save file metadata in the database
        <span class="cov0" title="0">image := models.AppFile{
                Filename: header.Filename,
                Url:      fmt.Sprintf("/%s", savePath),
        }
        database.DB.Create(&amp;image)

        ctx.JSON(http.StatusOK, gin.H{"message": "File uploaded successfully", "image": image})</span>
}

func (c *UploadController) GetFile(ctx *gin.Context) <span class="cov0" title="0">{
        taskId := ctx.Param("taskId")
        filename := ctx.Param("filename")

        // Construct the full file path
        filePath := fmt.Sprintf("uploads/%s/%s", taskId, filename)

        // Check if the file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "Image not found", "path": filePath})
                return
        }</span>

        // Serve the file
        <span class="cov0" title="0">ctx.File(filePath)</span>
}

func (c *UploadController) GetObject(ctx *gin.Context) <span class="cov0" title="0">{
        filename := ctx.Param("filename")

        // Construct the full file path
        filePath := filepath.Join("objects", filename)

        // Check if the file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "Object not found"})
                return
        }</span>

        // Serve the file
        <span class="cov0" title="0">ctx.File(filePath)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"

        repositories "github.com/Soup666/diss-api/repository"
        services "github.com/Soup666/diss-api/services"
        "github.com/gin-gonic/gin"
)

type VisionController struct {
        VisionService  services.VisionService
        TaskRepository repositories.TaskRepository
        TaskService    services.TaskService
}

func NewVisionController(visionService services.VisionService, taskRepository repositories.TaskRepository, taskService services.TaskService) *VisionController <span class="cov0" title="0">{
        return &amp;VisionController{VisionService: visionService, TaskRepository: taskRepository, TaskService: taskService}
}</span>

func (c *VisionController) AnalyzeTask(ctx *gin.Context) <span class="cov0" title="0">{

        taskIdParam := ctx.Param("taskID")
        taskId, err := strconv.Atoi(taskIdParam)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid task ID"})
                return
        }</span>

        <span class="cov0" title="0">task, err := c.TaskRepository.GetTaskByID(uint(taskId))

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "Task not found"})
                return
        }</span>

        <span class="cov0" title="0">c.TaskService.FullyLoadTask(task)

        if (len(task.Images)) == 0 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "No images found for the task"})
                return
        }</span>

        <span class="cov0" title="0">result, err := c.VisionService.AnalyseImage(fmt.Sprintf("./uploads/%d/%s", task.Id, task.Images[0].Filename), "")

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to analyze the image"})
                return
        }</span>

        <span class="cov0" title="0">c.TaskService.UpdateMeta(task, "ai-description", result)

        ctx.JSON(http.StatusOK, gin.H{"message": result})</span>
}

func (c *VisionController) AnalyzeImage(ctx *gin.Context) <span class="cov0" title="0">{

        file, _, err := ctx.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "File upload failed"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        f, err := os.CreateTemp("", "sample")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to save the file"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Temp file name:", f.Name())

        _, err = io.Copy(f, file)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to save the file"})
                return
        }</span>

        <span class="cov0" title="0">image := fmt.Sprintf("/%s", f.Name())

        defer os.Remove(f.Name())

        result, err := c.VisionService.AnalyseImage(image, "")

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to analyze the image"})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": result})</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "fmt"
        "log"
        "os"
        "testing"

        "github.com/Soup666/diss-api/model"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var DB *gorm.DB

func ConnectDatabase(connectionString string) error <span class="cov8" title="1">{
        var err error
        DB, err = gorm.Open(postgres.Open(connectionString), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error connecting to the database: ", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func SetupTestDB(t *testing.T) error <span class="cov8" title="1">{

        log.Println("Connecting to database...")
        log.Println(os.Getenv("DATABASE_URL"))

        dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s sslmode=disable TimeZone=%s", os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_TIMEZONE"))
        err := ConnectDatabase(dsn)

        ResetTestDB()

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to test DB: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">createEnumCommand := `
        --create types
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'taskstatus') THEN
        CREATE TYPE TaskStatus AS ENUM
        (
            'SUCCESS', 'INPROGRESS', 'FAILED', 'INITIAL'
        );
    END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'reporttype') THEN
        CREATE TYPE ReportType AS ENUM
        (
            'BUG', 'FEEDBACK'
        );
    END IF;
END$$;
`

        DB.Exec(createEnumCommand)

        err = DB.AutoMigrate(&amp;model.User{}, &amp;model.Task{}, &amp;model.Report{}, &amp;model.Collection{})

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to migrate test DB: %v", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ResetTestDB() <span class="cov8" title="1">{
        log.Println("Resetting test database...")

        tables := []string{"users", "tasks", "reports", "collections"}
        for _, table := range tables </span><span class="cov8" title="1">{
                truncateTableCommand := fmt.Sprintf("TRUNCATE TABLE %s RESTART IDENTITY CASCADE", table)
                DB.Exec(truncateTableCommand)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/tasks": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Creates a new task for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Create a new task",
                "parameters": [
                    {
                        "description": "Task data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controller.CreateTaskRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.Task"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/tasks/{taskID}/start": {
            "post": {
                "description": "Uploads files to a task",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Upload files to a task",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer Token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "Task data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controller.CreateTaskRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Task ID",
                        "name": "taskID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/tasks/{taskID}/upload": {
            "post": {
                "description": "Uploads files to a task",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Upload files to a task",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Task ID",
                        "name": "taskID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Files to upload",
                        "name": "files",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "controller.CreateTaskRequest": {
            "type": "object",
            "required": [
                "description",
                "title"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "model.AppFile": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "fileType": {
                    "type": "string"
                },
                "filename": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "taskID": {
                    "description": "Foreign key",
                    "type": "integer"
                },
                "updatedAt": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                }
            }
        },
        "model.Task": {
            "type": "object",
            "properties": {
                "completed": {
                    "type": "boolean"
                },
                "createdAt": {
                    "type": "string"
                },
                "deletedAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "images": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.AppFile"
                    }
                },
                "mesh": {
                    "$ref": "#/definitions/model.AppFile"
                },
                "status": {
                    "$ref": "#/definitions/model.TaskStatus"
                },
                "title": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "userID": {
                    "type": "integer"
                }
            }
        },
        "model.TaskStatus": {
            "type": "string",
            "enum": [
                "SUCCESS",
                "INPROGRESS",
                "FAILED",
                "INITIAL"
            ],
            "x-enum-varnames": [
                "SUCCESS",
                "INPROGRESS",
                "FAILED",
                "INITIAL"
            ]
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "context"
        "log"
        "os"

        "github.com/Soup666/diss-api/controller"
        db "github.com/Soup666/diss-api/database"
        repositories "github.com/Soup666/diss-api/repository"
        "github.com/Soup666/diss-api/router"
        "github.com/Soup666/diss-api/services"

        firebase "firebase.google.com/go/v4"
        "google.golang.org/api/option"

        _ "github.com/joho/godotenv/autoload"
)

func main() <span class="cov0" title="0">{
        // Set up the database connection
        log.Println("Connecting to database...")
        log.Println(os.Getenv("DATABASE_URL"))

        db.ConnectDatabase(os.Getenv("DATABASE_URL"))

        // Create a Firebase app instance
        opt := option.WithCredentialsFile("./service-account-key.json")
        app, err := firebase.NewApp(context.Background(), nil, opt)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create Firebase app: %v", err)
        }</span>

        // Create a Firebase auth client instance
        <span class="cov0" title="0">authClient, err := app.Auth(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create Firebase auth client: %v", err)
        }</span>

        <span class="cov0" title="0">userRepo := repositories.NewUserRepository(db.DB)
        taskRepo := repositories.NewTaskRepository(db.DB)
        appFileRepo := repositories.NewAppFileRepository(db.DB)
        reportsRepo := repositories.NewReportsRepository(db.DB)
        collectionsRepo := repositories.NewCollectionsRepository(db.DB)
        chatRepo := repositories.NewChatRepository(db.DB)

        // Set up the authentication service
        authService := services.NewAuthService(authClient, db.DB, userRepo)
        userService := services.NewUserService(userRepo)
        appFileService := services.NewAppFileServiceFile(appFileRepo)
        taskService := services.NewTaskService(taskRepo, appFileService, chatRepo)
        visionService := services.NewVisionService()
        reportsService := services.NewReportsService(reportsRepo)
        collectionsService := services.NewCollectionsService(collectionsRepo)

        authController := controller.NewAuthController(authService, userService)
        taskController := controller.NewTaskController(taskService, appFileService, visionService)
        uploadController := controller.NewUploadController()
        objectController := controller.NewObjectController()
        visionController := controller.NewVisionController(visionService, taskRepo, taskService)
        reportsController := controller.NewReportsController(reportsService)
        collectionsController := controller.NewCollectionsController(collectionsService)

        // Set up the HTTP router
        r := router.NewRouter(authController, taskController, uploadController, objectController, visionController, authService, reportsController, collectionsController)

        // Start the server
        if r.Run(":"+os.Getenv("PORT")) != nil </span><span class="cov0" title="0">{
                panic("[Error] failed to start Gin server due to: " + err.Error())</span>
        }

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/Soup666/diss-api/services"
        "github.com/gin-gonic/gin"
)

// AuthMiddleware checks the header for a valid API token
func AuthMiddleware(authService services.AuthService) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Get the `Authorization` header
                authHeader := c.GetHeader("Authorization")

                // Validate the header format (e.g., "Bearer &lt;token&gt;")
                if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid Authorization header"})
                        c.Abort()
                        return
                }</span>

                // Extract the token
                <span class="cov8" title="1">token := strings.TrimPrefix(authHeader, "Bearer ")

                authToken, err := authService.ValidateToken(token)

                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Token validation failed"})
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">user, err := authService.Verify(authToken.UID)

                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Unable to verify user"})
                        c.Abort()
                        return
                }</span>

                // Token is valid, proceed with the request
                <span class="cov8" title="1">c.Set("token", authToken.UID)
                c.Set("user", user)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import "github.com/gin-gonic/gin"

func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package model

import "database/sql/driver"

type ReportType string

const (
        BUG      ReportType = "BUG"
        FEEDBACK ReportType = "FEEDBACK"
)

func (ts *ReportType) Scan(value interface{}) error <span class="cov8" title="1">{
        *ts = ReportType(value.(string))
        return nil
}</span>

func (ts ReportType) Value() (driver.Value, error) <span class="cov8" title="1">{
        return string(ts), nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"

        "gorm.io/gorm"
)

type JSONMap map[string]interface{}

func (j *JSONMap) Scan(value interface{}) error <span class="cov8" title="1">{
        bytes, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>

        <span class="cov8" title="1">return json.Unmarshal(bytes, j)</span>
}

func (j JSONMap) Value() (driver.Value, error) <span class="cov8" title="1">{
        return json.Marshal(j)
}</span>

type Task struct {
        Id           uint `gorm:"primaryKey"`
        CreatedAt    time.Time
        UpdatedAt    time.Time
        DeletedAt    gorm.DeletedAt `gorm:"index"`
        Title        string
        Description  string
        Completed    bool
        Status       TaskStatus `gorm:"type:TaskStatus"`
        UserId       *uint
        Images       []AppFile     `gorm:"foreignKey:TaskId"`
        Mesh         *AppFile      `gorm:"foreignKey:TaskId"`
        Metadata     JSONMap       `gorm:"type:json" json:"Metadata"`
        ChatMessages []ChatMessage `gorm:"foreignKey:TaskId"`
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import "database/sql/driver"

type TaskStatus string

const (
        SUCCESS    TaskStatus = "SUCCESS"
        INPROGRESS TaskStatus = "INPROGRESS"
        FAILED     TaskStatus = "FAILED"
        INITIAL    TaskStatus = "INITIAL"
)

func (ts *TaskStatus) Scan(value interface{}) error <span class="cov8" title="1">{
        *ts = TaskStatus(value.(string))
        return nil
}</span>

func (ts TaskStatus) Value() (driver.Value, error) <span class="cov8" title="1">{
        return string(ts), nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package repositories

import (
        "github.com/Soup666/diss-api/database"
        "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

type AppFileRepositoryImpl struct {
        DB *gorm.DB
}

func NewAppFileRepository(db *gorm.DB) AppFileRepository <span class="cov0" title="0">{
        return &amp;AppFileRepositoryImpl{DB: db}
}</span>

func (repo *AppFileRepositoryImpl) SaveAppFile(appFile *model.AppFile) (*model.AppFile, error) <span class="cov0" title="0">{
        if err := database.DB.Save(&amp;appFile).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return appFile, nil</span>
}

func (repo *AppFileRepositoryImpl) GetAppFilesByTask(taskID uint, fileType string) ([]model.AppFile, error) <span class="cov0" title="0">{
        var appFiles []model.AppFile
        if err := database.DB.Where("task_id = ? AND file_type = ?", taskID, fileType).Find(&amp;appFiles).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return appFiles, nil</span>
}

func (repo *AppFileRepositoryImpl) GetAppFileByTask(taskID uint, fileType string) (*model.AppFile, error) <span class="cov0" title="0">{
        var appFile model.AppFile
        if err := database.DB.Where("task_id = ? AND file_type = ?", taskID, fileType).First(&amp;appFile).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;appFile, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repositories

import (
        "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

type ChatRepositoryImpl struct {
        DB *gorm.DB
}

func NewChatRepository(db *gorm.DB) ChatRepository <span class="cov0" title="0">{
        return &amp;ChatRepositoryImpl{DB: db}
}</span>

// CreateChat implements ChatRepository.
func (c *ChatRepositoryImpl) CreateChat(chat *model.ChatMessage) error <span class="cov0" title="0">{
        if err := c.DB.Create(chat).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repositories

import (
        "github.com/Soup666/diss-api/database"
        models "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

type CollectionsRepositoryImpl struct {
        DB *gorm.DB
}

func NewCollectionsRepository(db *gorm.DB) CollectionsRepository <span class="cov8" title="1">{
        return &amp;CollectionsRepositoryImpl{DB: db}
}</span>

func (repo *CollectionsRepositoryImpl) GetCollectionsByUser(userID uint) ([]models.Collection, error) <span class="cov0" title="0">{
        var collections []models.Collection
        if err := database.DB.
                Preload("Tasks").
                Where("user_id = ?", userID).
                Find(&amp;collections).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return collections, nil</span>
}

func (repo *CollectionsRepositoryImpl) GetCollectionByID(collectionID uint) (*models.Collection, error) <span class="cov8" title="1">{
        var collection models.Collection
        if err := database.DB.
                Preload("Tasks").
                Model(&amp;models.Collection{}).
                Where("id = ?", collectionID).
                First(&amp;collection).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;collection, nil</span>
}

func (repo *CollectionsRepositoryImpl) CreateCollection(collection *models.Collection) error <span class="cov8" title="1">{
        if err := database.DB.
                Model(&amp;models.Collection{}).
                Create(collection).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (repo *CollectionsRepositoryImpl) SaveCollection(collection *models.Collection) error <span class="cov8" title="1">{
        if err := database.DB.Save(collection).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (repo *CollectionsRepositoryImpl) ArchiveCollection(collectionID uint) error <span class="cov0" title="0">{
        if err := database.DB.Delete(&amp;models.Collection{}, collectionID).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (repo *CollectionsRepositoryImpl) GetCollectionTasks(collectionID uint) ([]models.Task, error) <span class="cov0" title="0">{
        var tasks []models.Task
        if err := database.DB.Model(&amp;models.Collection{}).
                Where("id = ?", collectionID).
                Association("Tasks").Find(&amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repositories

import (
        "github.com/Soup666/diss-api/database"
        models "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

type ReportsRepositoryImpl struct {
        DB *gorm.DB
}

func NewReportsRepository(db *gorm.DB) ReportsRepository <span class="cov8" title="1">{
        return &amp;ReportsRepositoryImpl{DB: db}
}</span>

func (repo *ReportsRepositoryImpl) GetReportsByUser(userID uint) ([]models.Report, error) <span class="cov0" title="0">{
        var reports []models.Report
        if err := database.DB.Model(&amp;models.Report{}).Where("user_id = ?", userID).Find(&amp;reports).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return reports, nil</span>
}

func (repo *ReportsRepositoryImpl) GetReportByID(reportID uint) (*models.Report, error) <span class="cov8" title="1">{
        var report models.Report
        if err := database.DB.Model(&amp;models.Report{}).Where("id = ?", reportID).First(&amp;report).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;report, nil</span>
}

func (repo *ReportsRepositoryImpl) CreateReport(report *models.Report) error <span class="cov8" title="1">{
        if err := database.DB.Model(&amp;models.Report{}).Create(report).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (repo *ReportsRepositoryImpl) SaveReport(report *models.Report) error <span class="cov8" title="1">{
        if err := database.DB.Save(report).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (repo *ReportsRepositoryImpl) ArchiveReport(reportID uint) error <span class="cov0" title="0">{
        if err := database.DB.Delete(&amp;models.Report{}, reportID).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repositories

import (
        "github.com/Soup666/diss-api/database"
        models "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

type TaskRepositoryImpl struct {
        DB *gorm.DB
}

func NewTaskRepository(db *gorm.DB) TaskRepository <span class="cov8" title="1">{
        return &amp;TaskRepositoryImpl{DB: db}
}</span>

func (repo *TaskRepositoryImpl) GetTasksByUser(userID uint) ([]*models.Task, error) <span class="cov0" title="0">{
        // Fetch tasks related to the user
        var tasks []*models.Task
        if err := database.DB.Where("user_id = ?", userID).Find(&amp;tasks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
}

func (repo *TaskRepositoryImpl) GetTaskByID(taskID uint) (*models.Task, error) <span class="cov8" title="1">{
        var task models.Task
        if err := database.DB.Where("id = ?", taskID).First(&amp;task).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;task, nil</span>
}

// CreateTask creates a new task in the database
func (repo *TaskRepositoryImpl) CreateTask(task *models.Task) error <span class="cov8" title="1">{
        if err := database.DB.Create(task).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (repo *TaskRepositoryImpl) SaveTask(task *models.Task) error <span class="cov8" title="1">{
        if err := database.DB.Save(task).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (repo *TaskRepositoryImpl) ArchiveTask(task *models.Task) error <span class="cov0" title="0">{
        if err := database.DB.Delete(task).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repositories

import (
        "github.com/Soup666/diss-api/database"
        models "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

type UserRepositoryImpl struct {
        DB *gorm.DB
}

func NewUserRepository(db *gorm.DB) UserRepository <span class="cov8" title="1">{
        return &amp;UserRepositoryImpl{DB: db}
}</span>

func (repo *UserRepositoryImpl) GetUserFromFirebaseUID(apiKey string) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        if err := database.DB.Where("firebase_uid = ?", apiKey).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (repo *UserRepositoryImpl) Create(user *models.User) error <span class="cov8" title="1">{
        return repo.DB.Create(&amp;user).Error
}</span>

func (repo *UserRepositoryImpl) UpdateUser(user *models.User) error <span class="cov8" title="1">{
        return repo.DB.Save(&amp;user).Error
}</span>

func (repo *UserRepositoryImpl) GetUsers() ([]*models.User, error) <span class="cov8" title="1">{
        var users []*models.User
        if err := database.DB.Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package router

import (
        "github.com/Soup666/diss-api/controller"
        "github.com/Soup666/diss-api/middleware"
        "github.com/Soup666/diss-api/services"
        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"

        _ "github.com/Soup666/diss-api/docs"
)

func NewRouter(
        authController *controller.AuthController,
        taskController *controller.TaskController,
        uploadController *controller.UploadController,
        objectController *controller.ObjectController,
        visionController *controller.VisionController,
        authService services.AuthService,
        reportsController *controller.ReportsController,
        collectionsController *controller.CollectionsController,
) *gin.Engine <span class="cov0" title="0">{

        r := gin.Default()

        // Global middlewares
        r.Use(middleware.CORSMiddleware())

        // Swagger route
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Authenticated routes
        authRequired := r.Group("/")
        authRequired.Use(middleware.AuthMiddleware(authService))

        // Authentication routes
        authRequired.POST("/verify", authController.Verify)
        authRequired.PATCH("/verify", authController.Verify)

        // Tasks (protected by AuthMiddleware)
        authRequired.GET("/tasks", taskController.GetTasks)
        authRequired.POST("/tasks", taskController.CreateTask)
        authRequired.PUT("/tasks", taskController.UpdateTask)
        authRequired.GET("/tasks/:taskID", taskController.GetTask)
        authRequired.POST("/tasks/:taskID/upload", taskController.UploadFileToTask)
        authRequired.POST("/tasks/:taskID/start", taskController.StartProcess)
        authRequired.POST("/tasks/:taskID/message", taskController.SendMessage)

        // Reports
        authRequired.GET("/reports", reportsController.GetReports)
        authRequired.POST("/reports", reportsController.CreateReport)
        authRequired.GET("/reports/:reportID", reportsController.GetReportByID)
        authRequired.PUT("/reports", reportsController.SaveReport)

        // Collections
        authRequired.GET("/collections", collectionsController.GetCollections)
        authRequired.POST("/collections", collectionsController.CreateCollection)
        authRequired.GET("/collections/:collectionID", collectionsController.GetCollection)
        authRequired.PUT("/collections", collectionsController.SaveCollection)
        authRequired.DELETE("/collections/:collectionID", collectionsController.ArchiveCollection)

        // Image analysis
        authRequired.POST("/analyze", visionController.AnalyzeImage)
        authRequired.POST("/analyze/:taskID", visionController.AnalyzeTask)

        // Unauthenticated routes
        r.POST("/uploads", uploadController.UploadFile)
        r.GET("/uploads/:taskId/:filename", uploadController.GetFile)
        r.GET("/objects/:taskID/model", objectController.GetObject)

        return r
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "log"
        "os"

        "github.com/Soup666/diss-api/seeds"
        _ "github.com/joho/godotenv/autoload"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func main() <span class="cov0" title="0">{
        log.Println("Starting seeding database...")
        DB, err := gorm.Open(postgres.Open(os.Getenv("DATABASE_URL")), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error connecting to the database: ", err)
        }</span>

        <span class="cov0" title="0">for _, seed := range seeds.All() </span><span class="cov0" title="0">{
                log.Printf("Running seed '%s'", seed.Name)
                if err := seed.Run(DB); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Running seed '%s', failed with error: %s", seed.Name, err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Seeding completed successfully")

        log.Println("Backing up files...")
        if err := seeds.MakeBackup(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error backing up files: %s", err)
        }</span>

        <span class="cov0" title="0">log.Println("Moving files...")
        if err := seeds.CopyFiles(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error moving files: %s", err)
        }</span>

        <span class="cov0" title="0">log.Println("Files moved successfully")
        log.Println("Seeding and file operations completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package seeds

import (
        "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

func CreateFile(db *gorm.DB, taskID uint, url string, filename string, filetype string) error <span class="cov0" title="0">{
        return db.Create(&amp;model.AppFile{TaskId: taskID, Url: url, Filename: filename, FileType: filetype}).Error
}</span>

var filenames = []string{
        "2-0.png",
        "2-1.png",
        "2-2.png",
        "2-3.png",
        "2-4.png",
        "2-5.png",
        "2-6.png",
        "2-7.png",
        "2-8.png",
        "2-9.png",
        "2-10.png",
        "2-11.png",
        "2-12.png",
        "2-13.png",
        "2-14.png",
        "2-15.png",
        "2-16.png",
        "2-17.png",
        "2-18.png",
        "2-19.png",
        "2-20.png",
        "2-21.png",
        "2-22.png",
        "2-23.png",
        "2-24.png",
        "2-25.png",
        "2-26.png",
        "2-27.png",
        "2-28.png",
        "2-29.png",
        "2-30.png",
        "2-31.png",
        "2-32.png",
        "2-33.png",
        "2-34.png",
        "2-35.png",
        "2-36.png",
        "2-37.png",
        "2-38.png",
        "2-39.png",
        "2-40.png",
        "2-41.png",
        "2-42.png",
        "2-43.png",
        "2-44.png",
        "2-45.png",
        "2-46.png",
        "2-47.png",
        "2-48.png",
        "2-49.png",
        "2-50.png",
        "2-51.png",
        "2-52.png",
        "2-53.png",
        "2-54.png",
        "2-55.png",
        "2-56.png",
        "2-57.png",
        "2-58.png",
        "2-59.png",
        "2-60.png",
        "2-61.png",
        "2-62.png",
        "2-63.png",
        "2-64.png",
        "2-65.png",
        "2-66.png",
        "2-67.png",
        "2-68.png",
        "2-69.png",
        "2-70.png",
        "2-71.png",
        "2-72.png",
        "2-73.png",
        "2-74.png",
        "2-75.png",
        "2-76.png",
        "2-77.png",
        "2-78.png",
        "2-79.png",
        "2-80.png",
        "2-81.png",
        "2-82.png",
}

func CreateDummyFiles(db *gorm.DB) error <span class="cov0" title="0">{
        for _, filename := range filenames </span><span class="cov0" title="0">{
                if err := CreateFile(db, 1, "/uploads/1/"+filename, filename, "upload"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package seeds

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/Soup666/diss-api/seed"
        "github.com/Soup666/diss-api/utils"
        "gorm.io/gorm"
)

func MakeBackup() error <span class="cov0" title="0">{
        srcDirs := [2]string{"./uploads", "./objects"}
        destDir := "./backup/"

        err := os.MkdirAll(destDir, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, srcDir := range srcDirs </span><span class="cov0" title="0">{
                os.Rename(srcDir, filepath.Join(destDir, filepath.Base(srcDir)))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func CopyFiles() error <span class="cov0" title="0">{
        util := utils.NewFileUtil()

        // Example paths
        currentDir, _ := os.Getwd()
        srcFile := filepath.Join(currentDir, "seeds", "backup", "backup.tar.gz")
        destFile := filepath.Join(currentDir, "backup.tar.gz")

        // Step 1: Copy tar.gz
        if err := util.CopyFile(srcFile, destFile); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Copy failed: %v\n", err)
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Println("Tar.gz copied successfully.")

        // Step 2: Extract
        f, err := os.Open(destFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open tar.gz: %v\n", err)
                return nil
        }</span>
        <span class="cov0" title="0">defer f.Close()

        if err := util.ExtractTarGz(f, currentDir); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Extraction failed: %v\n", err)
                return nil
        }</span>

        // Step 3: Remove tar.gz

        <span class="cov0" title="0">if err := os.Remove(destFile); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to remove tar.gz: %v\n", err)
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Println("Extraction successful.")

        return nil</span>
}

func All() []seed.Seed <span class="cov0" title="0">{
        return []seed.Seed{
                {
                        Name: "CreateTestUser",
                        Run: func(db *gorm.DB) error </span><span class="cov0" title="0">{
                                return CreateUser(db, "Seed User", "KQmrXe88TwebIMh6AkbEV251Aec2")
                        }</span>,
                },
                {
                        Name: "CreateTestTask",
                        Run: func(db *gorm.DB) error <span class="cov0" title="0">{
                                return CreateTask(db, "Seed Figure", "This is seeded data to represent an example scan", true, 1)
                        }</span>,
                },
                {
                        Name: "CreateTestFiles",
                        Run: func(db *gorm.DB) error <span class="cov0" title="0">{
                                return CreateDummyFiles(db)
                        }</span>,
                },
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package seeds

import (
        "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

func CreateTask(db *gorm.DB, title string, description string, completed bool, userId uint) error <span class="cov0" title="0">{
        return db.Create(&amp;model.Task{
                Title:       title,
                Description: description,
                Completed:   completed,
                UserId:      &amp;userId,
                Images:      []model.AppFile{},
                Status:      "INITIAL",
                Metadata:    map[string]interface{}{},
        }).Error
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package seeds

import (
        "github.com/Soup666/diss-api/model"
        "gorm.io/gorm"
)

func CreateUser(db *gorm.DB, email string, firebaseUid string) error <span class="cov0" title="0">{
        return db.Create(&amp;model.User{Email: email, FirebaseUid: firebaseUid}).Error
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        models "github.com/Soup666/diss-api/model"
        repositories "github.com/Soup666/diss-api/repository"
)

type AppFileServiceImpl struct {
        appFileRepo repositories.AppFileRepository
}

func NewAppFileServiceFile(appFileRepo repositories.AppFileRepository) AppFileService <span class="cov0" title="0">{
        return &amp;AppFileServiceImpl{appFileRepo: appFileRepo}
}</span>

func (s *AppFileServiceImpl) Save(appFile *models.AppFile) (*models.AppFile, error) <span class="cov0" title="0">{
        appFile, err := s.appFileRepo.SaveAppFile(appFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return appFile, nil</span>
}

func (s *AppFileServiceImpl) GetTaskFiles(taskID uint, fileType string) ([]models.AppFile, error) <span class="cov0" title="0">{
        appFiles, err := s.appFileRepo.GetAppFilesByTask(taskID, fileType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return appFiles, nil</span>
}

func (s *AppFileServiceImpl) GetTaskFile(taskID uint, fileType string) (*models.AppFile, error) <span class="cov0" title="0">{
        var appFile *models.AppFile
        appFile, err := s.appFileRepo.GetAppFileByTask(taskID, fileType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return appFile, nil</span>

}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "context"
        "errors"

        "firebase.google.com/go/v4/auth"
        "github.com/Soup666/diss-api/model"
        repositories "github.com/Soup666/diss-api/repository"
        "gorm.io/gorm"
)

type AuthServiceImpl struct {
        FireAuth *auth.Client
        DB       *gorm.DB
        userRepo repositories.UserRepository
}

func NewAuthService(FireAuth *auth.Client, DB *gorm.DB, userRepo repositories.UserRepository) AuthService <span class="cov0" title="0">{
        return &amp;AuthServiceImpl{FireAuth: FireAuth, DB: DB, userRepo: userRepo}
}</span>

func (s *AuthServiceImpl) ValidateToken(token string) (*auth.Token, error) <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return nil, errors.New("token is empty")
        }</span>

        <span class="cov0" title="0">authToken, err := s.FireAuth.VerifyIDToken(context.Background(), token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return authToken, nil</span>
}

func (s *AuthServiceImpl) Verify(token string) (*model.User, error) <span class="cov0" title="0">{

        user, err := s.userRepo.GetUserFromFirebaseUID(token)

        if err == gorm.ErrRecordNotFound || user == nil </span><span class="cov0" title="0">{
                user := &amp;model.User{
                        FirebaseUid: token,
                }

                // Create blank user if not found
                err := s.userRepo.Create(user)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("unable to verify user")
                }</span>

                <span class="cov0" title="0">return user, nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("unable to verify user")
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "github.com/Soup666/diss-api/model"
        repositories "github.com/Soup666/diss-api/repository"
)

type CollectionsServiceImpl struct {
        collectionsRepo repositories.CollectionsRepository
}

func NewCollectionsService(collectionsRepo repositories.CollectionsRepository) CollectionsService <span class="cov0" title="0">{
        return &amp;CollectionsServiceImpl{collectionsRepo: collectionsRepo}
}</span>

func (s *CollectionsServiceImpl) CreateCollection(collection *model.Collection) error <span class="cov0" title="0">{

        if err := s.collectionsRepo.CreateCollection(collection); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *CollectionsServiceImpl) GetCollection(collectionID uint) (*model.Collection, error) <span class="cov0" title="0">{
        report, err := s.collectionsRepo.GetCollectionByID(collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return report, nil</span>
}

func (s *CollectionsServiceImpl) GetCollections(userID uint) ([]model.Collection, error) <span class="cov0" title="0">{
        reports, err := s.collectionsRepo.GetCollectionsByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return reports, nil</span>
}

func (s *CollectionsServiceImpl) ArchiveCollection(collectionID uint) error <span class="cov0" title="0">{
        err := s.collectionsRepo.ArchiveCollection(collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *CollectionsServiceImpl) SaveCollection(collection *model.Collection) error <span class="cov0" title="0">{
        if err := s.collectionsRepo.SaveCollection(collection); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "io"
        "mime/multipart"
        "os"
)

type FileServiceImpl struct{}

func NewFileService() *FileServiceImpl <span class="cov0" title="0">{
        return &amp;FileServiceImpl{}
}</span>

func (c *FileServiceImpl) SaveTempFile(file *multipart.File) (string, error) <span class="cov0" title="0">{
        f, err := os.CreateTemp("", "sample")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(f, *file)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return f.Name(), nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "github.com/Soup666/diss-api/model"
        repositories "github.com/Soup666/diss-api/repository"
)

type ReportsServiceImpl struct {
        reportsRepo repositories.ReportsRepository
}

func NewReportsService(reportsRepo repositories.ReportsRepository) ReportsService <span class="cov0" title="0">{
        return &amp;ReportsServiceImpl{reportsRepo: reportsRepo}
}</span>

func (s *ReportsServiceImpl) CreateReport(report *model.Report) error <span class="cov0" title="0">{

        if err := s.reportsRepo.CreateReport(report); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *ReportsServiceImpl) GetReport(reportID uint) (*model.Report, error) <span class="cov0" title="0">{
        report, err := s.reportsRepo.GetReportByID(reportID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return report, nil</span>
}

func (s *ReportsServiceImpl) GetReports(userID uint) ([]model.Report, error) <span class="cov0" title="0">{
        reports, err := s.reportsRepo.GetReportsByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return reports, nil</span>
}

func (s *ReportsServiceImpl) ArchiveReport(reportID uint) error <span class="cov0" title="0">{
        err := s.reportsRepo.ArchiveReport(reportID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *ReportsServiceImpl) SaveReport(report *model.Report) error <span class="cov0" title="0">{
        if err := s.reportsRepo.SaveReport(report); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import (
        "errors"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "time"

        models "github.com/Soup666/diss-api/model"
        repositories "github.com/Soup666/diss-api/repository"
        "gorm.io/gorm"
)

type TaskServiceImpl struct {
        taskRepo       repositories.TaskRepository
        appFileService AppFileService
        chatRepository repositories.ChatRepository
}

func NewTaskService(taskRepo repositories.TaskRepository, appFileService AppFileService, chatRepository repositories.ChatRepository) TaskService <span class="cov8" title="1">{
        return &amp;TaskServiceImpl{taskRepo: taskRepo, appFileService: appFileService, chatRepository: chatRepository}
}</span>

func (s *TaskServiceImpl) CreateTask(task *models.Task) error <span class="cov8" title="1">{
        err := s.taskRepo.CreateTask(task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *TaskServiceImpl) GetTask(taskID uint) (*models.Task, error) <span class="cov8" title="1">{
        task, err := s.taskRepo.GetTaskByID(taskID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return task, nil</span>
}

func (s *TaskServiceImpl) GetTasks(userID uint) ([]*models.Task, error) <span class="cov8" title="1">{

        tasks, err := s.taskRepo.GetTasksByUser(userID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return tasks, nil</span>

}

func (s *TaskServiceImpl) UpdateTask(task *models.Task) (*models.Task, error) <span class="cov0" title="0">{

        err := s.taskRepo.SaveTask(task)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}

func (s *TaskServiceImpl) UpdateMeta(task *models.Task, key string, value interface{}) error <span class="cov0" title="0">{
        if task.Metadata == nil </span><span class="cov0" title="0">{
                task.Metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">task.Metadata[key] = value
        _, err := s.UpdateTask(task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *TaskServiceImpl) ArchiveTask(taskID uint) error <span class="cov0" title="0">{

        task, err := s.taskRepo.GetTaskByID(taskID)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.taskRepo.ArchiveTask(task)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *TaskServiceImpl) SaveTask(task *models.Task) error <span class="cov0" title="0">{
        err := s.taskRepo.SaveTask(task)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *TaskServiceImpl) DeleteTask(taskID *models.Task) error <span class="cov0" title="0">{
        err := s.taskRepo.ArchiveTask(taskID)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *TaskServiceImpl) FailTask(task *models.Task) error <span class="cov0" title="0">{
        task.Status = models.FAILED
        _, err := s.UpdateTask(task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *TaskServiceImpl) RunPhotogrammetryProcess(task *models.Task) error <span class="cov0" title="0">{
        startTime := time.Now()

        TASK_COUNT := 7
        CURRENT_TASK := 0

        inputPath := filepath.Join("uploads", fmt.Sprintf("%d", task.Id))
        outputPath := filepath.Join("objects", fmt.Sprintf("%d", task.Id))
        mvsPath := filepath.Join(outputPath, "mvs")

        task.Status = models.INPROGRESS
        if _, err := s.UpdateTask(task); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update task status to INPROGRESS: %v\n", err)
                return err
        }</span>

        // Clear the build directory
        <span class="cov0" title="0">if err := os.RemoveAll(outputPath); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to clear directory %s: %v", outputPath, err)
                s.FailTask(task)
                return err
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(outputPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create directory %s: %v", outputPath, err)
                s.FailTask(task)
                return err
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(mvsPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create directory %s: %v", mvsPath, err)
                s.FailTask(task)
                return err
        }</span>

        // 1
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        log.Println("# 1 ./bin/SfM_SequentialPipeline.py", inputPath, outputPath, "--opensfm-processes", "8")
        cmd := exec.Command("./bin/SfM_SequentialPipeline.py", inputPath, outputPath, "--opensfm-processes", "8")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err := cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("SfM_SequentialPipeline failed:", err)
                s.FailTask(task)
                return err
        }</span>

        // 2
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        log.Println("# 2 openMVG_main_openMVG2openMVS", "-i", filepath.Join(outputPath, "reconstruction_sequential/sfm_data.bin"), "-o", filepath.Join(mvsPath, "scene.mvs"), inputPath, outputPath, "-d", mvsPath)
        cmd = exec.Command("openMVG_main_openMVG2openMVS", "-i", filepath.Join(outputPath, "reconstruction_sequential/sfm_data.bin"), "-o", filepath.Join(mvsPath, "scene.mvs"), inputPath, outputPath, "-d", mvsPath)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err = cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("openMVG_main_openMVG2openMVS failed:", err)
                s.FailTask(task)
                return err
        }</span>

        // 3
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        log.Println("# 3 DensifyPointCloud", "scene.mvs", "-o", "scene_dense.mvs", "-w", mvsPath)
        cmd = exec.Command("DensifyPointCloud", "scene.mvs", "-o", "scene_dense.mvs", "-w", mvsPath)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err = cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("DensifyPointCloud failed:", err)
                s.FailTask(task)
                return err
        }</span>

        // 4
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        log.Println("# 4 ReconstructMesh", "scene_dense.mvs", "-o", "scene_mesh.ply", "-w", mvsPath)
        cmd = exec.Command("ReconstructMesh", "scene_dense.mvs", "-o", "scene_mesh.ply", "-w", mvsPath)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err = cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("ReconstructMesh failed:", err)
                s.FailTask(task)
                return err
        }</span>

        // 5
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        log.Println("# 5 RefineMesh", "scene.mvs", "-m", "scene_mesh.ply", "-o", "scene_dense_mesh_refine.mvs", "-w", mvsPath, "--scales", "1", "--max-face-area", "16")
        cmd = exec.Command("RefineMesh", "scene.mvs", "-m", "scene_mesh.ply", "-o", "scene_dense_mesh_refine.mvs", "-w", mvsPath, "--scales", "1", "--max-face-area", "16")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err = cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("RefineMesh failed:", err)
                s.FailTask(task)
                return err
        }</span>

        // 6
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        log.Println("# 6 TextureMesh", "scene_dense.mvs", "-m", "scene_dense_mesh_refine.ply", "-o", "scene_dense_mesh_refine_texture.mvs", "-w", mvsPath, "--export-type", "obj")
        cmd = exec.Command("TextureMesh", "scene_dense.mvs", "-m", "scene_dense_mesh_refine.ply", "-o", "scene_dense_mesh_refine_texture.mvs", "-w", mvsPath, "--export-type", "obj")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err = cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("TextureMesh failed:", err)
                s.FailTask(task)
                return err
        }</span>

        // 7
        <span class="cov0" title="0">log.Println("Updating meta for task:", task.Id, " - ", CURRENT_TASK, "/", TASK_COUNT)
        if err := s.UpdateMeta(task, "opensfm-process", CURRENT_TASK/100); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update meta: %d: %v\n", CURRENT_TASK, err)
                return err
        }</span>
        <span class="cov0" title="0">CURRENT_TASK++

        fileName := filepath.Join(mvsPath, "final_model")
        fmt.Println("blender", "-b", "-P", "./bin/convert_obj_to_glb.py", "--", filepath.Join(mvsPath, "scene_dense_mesh_refine_texture.obj"), fileName)
        cmd = exec.Command("blender", "-b", "-P", "./bin/convert_obj_to_glb.py", "--", filepath.Join(mvsPath, "scene_dense_mesh_refine_texture.obj"), fileName)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err = cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                log.Println("MeshConversion failed:", err)
                s.FailTask(task)
                return err
        }</span>

        <span class="cov0" title="0">mesh, err := s.appFileService.Save(&amp;models.AppFile{
                Url:      fileName + ".glb",
                Filename: "final_model.glb",
                TaskId:   task.Id,
                FileType: "mesh",
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to save mesh: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">task.Mesh = mesh
        task.Completed = true
        task.Status = models.SUCCESS

        if _, err := s.UpdateTask(task); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update task: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Println("Task updated successfully.")
        log.Printf("Processing completed in %s\n", time.Since(startTime))
        return nil</span>
}

func (s *TaskServiceImpl) GetTaskFiles(taskID uint, fileType string) ([]models.AppFile, error) <span class="cov0" title="0">{
        files, err := s.appFileService.GetTaskFiles(taskID, fileType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return files, nil</span>
}

func (s *TaskServiceImpl) GetTaskFile(taskID uint, fileType string) (*models.AppFile, error) <span class="cov0" title="0">{
        file, err := s.appFileService.GetTaskFile(taskID, fileType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

func (s *TaskServiceImpl) FullyLoadTask(task *models.Task) (*models.Task, error) <span class="cov0" title="0">{
        files, err := s.GetTaskFiles(task.Id, "upload")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">task.Images = files

        mesh, err := s.GetTaskFile(task.Id, "mesh")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        task.Mesh = nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                task.Mesh = mesh
        }</span>

        <span class="cov0" title="0">return task, nil</span>
}

func (s *TaskServiceImpl) SendMessage(taskID uint, message string, sender string) (*models.ChatMessage, error) <span class="cov0" title="0">{
        chatMessage := &amp;models.ChatMessage{
                Message: message,
                TaskId:  taskID,
                Sender:  sender,
        }

        err := s.chatRepository.CreateChat(chatMessage)
        if err != nil </span><span class="cov0" title="0">{
                return chatMessage, err
        }</span>
        <span class="cov0" title="0">return chatMessage, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "errors"

        models "github.com/Soup666/diss-api/model"
        repositories "github.com/Soup666/diss-api/repository"
)

type UserServiceImpl struct {
        userRepo repositories.UserRepository
}

func NewUserService(userRepo repositories.UserRepository) UserService <span class="cov8" title="1">{
        return &amp;UserServiceImpl{userRepo: userRepo}
}</span>

func (s *UserServiceImpl) GetUserFromFirebaseUID(apiKey string) (*models.User, error) <span class="cov8" title="1">{

        if apiKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("api key is required")
        }</span>

        <span class="cov8" title="1">user, err := s.userRepo.GetUserFromFirebaseUID(apiKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func (s *UserServiceImpl) UpdateUser(user *models.User) error <span class="cov8" title="1">{
        return s.userRepo.UpdateUser(user)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "log"
        "os"
        "strings"

        "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
)

type VisionServiceImpl struct{}

func NewVisionService() VisionService <span class="cov0" title="0">{
        return &amp;VisionServiceImpl{}
}</span>

func (s *VisionServiceImpl) AnalyseImage(imagePath string, prompt string) (string, error) <span class="cov0" title="0">{
        if prompt == "" </span><span class="cov0" title="0">{
                prompt = "Caption this image, give one sentence only"
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        client, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv("GEMINI_API_KEY")))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        model := client.GenerativeModel("gemini-2.0-flash")

        file, err := os.Open(imagePath)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        imageBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Create the request.
        <span class="cov0" title="0">req := []genai.Part{
                genai.ImageData("jpeg", imageBytes),
                genai.Text(prompt),
        }

        // Generate content.
        resp, err := model.GenerateContent(ctx, req...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var result string = extractText(resp)

        return result, nil</span>
}

func extractText(resp *genai.GenerateContentResponse) string <span class="cov0" title="0">{
        var builder strings.Builder

        for _, cand := range resp.Candidates </span><span class="cov0" title="0">{
                if cand.Content != nil </span><span class="cov0" title="0">{
                        for _, part := range cand.Content.Parts </span><span class="cov0" title="0">{
                                fmt.Println(part)
                                if text, ok := part.(genai.Text); ok </span><span class="cov0" title="0">{
                                        builder.WriteString(string(text))
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return builder.String()</span>

}
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import (
        "archive/tar"
        "compress/gzip"
        "fmt"
        "io"
        "os"
        "path/filepath"
)

type FileUtil struct{}

func NewFileUtil() *FileUtil <span class="cov0" title="0">{
        return &amp;FileUtil{}
}</span>

// CopyFile copies a file from src to dest
func (f *FileUtil) CopyFile(src, dest string) error <span class="cov0" title="0">{
        from, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer from.Close()

        to, err := os.Create(dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer to.Close()

        _, err = io.Copy(to, from)
        return err</span>
}

// ExtractTarGz extracts a .tar.gz file from an io.Reader to a destination directory
func (f *FileUtil) ExtractTarGz(gzipStream io.Reader, destDir string) error <span class="cov0" title="0">{
        uncompressedStream, err := gzip.NewReader(gzipStream)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer uncompressedStream.Close()

        tarReader := tar.NewReader(uncompressedStream)

        for </span><span class="cov0" title="0">{
                header, err := tarReader.Next()

                switch </span>{
                case err == io.EOF:<span class="cov0" title="0">
                        return nil</span>
                case err != nil:<span class="cov0" title="0">
                        return err</span>
                case header == nil:<span class="cov0" title="0">
                        continue</span>
                }

                <span class="cov0" title="0">target := filepath.Join(destDir, header.Name)

                switch header.Typeflag </span>{
                case tar.TypeDir:<span class="cov0" title="0">
                        if err := os.MkdirAll(target, os.FileMode(header.Mode)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case tar.TypeReg:<span class="cov0" title="0">
                        if err := os.MkdirAll(filepath.Dir(target), 0755); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">outFile, err := os.Create(target)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if _, err := io.Copy(outFile, tarReader); err != nil </span><span class="cov0" title="0">{
                                outFile.Close()
                                return err
                        }</span>
                        <span class="cov0" title="0">outFile.Close()</span>
                default:<span class="cov0" title="0">
                        fmt.Printf("Unknown type: %v in %s\n", header.Typeflag, header.Name)</span>
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
